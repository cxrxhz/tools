## 一、总体流程

程序的目标是对一条随时间变化的信号（例如 y1 或 y2）进行“基线扣除”，也就是在每个完整的波周期内剔除零点偏移，从而保留每个波（周期）的真实**变化量**（振幅）。为了实现这一目标，代码主要做了以下几步：

1. **数据读取** 从文件中逐行提取数值数据，跳过不能转换为数字的说明行（如含有“R01:”的行）。
    
2. **信号平滑** 使用 Savitzky–Golay 滤波器对原始信号进行平滑处理，减少高频噪声，使得后续的波谷检测更加稳定。
    
3. **波谷检测与分段** 通过对平滑后的信号取反，再利用 `find_peaks` 检测局部峰值，从而检测原信号中的局部最小值（即波谷）。 根据检测到的波谷位置（还会保证信号第一点和最后一点作为边界），将整个信号划分为一个个完整的波周期。
    
4. **基线扣除和振幅计算** 对于每个波段（完整周期），以该周期内的最小值作为**基线**（即理论上零电平的位置） 并用该周期的 **最大值** 与该基线的差作为该波的振幅（变化量）。 然后将该周期内所有数据点都扣除这个基线，使得该波的最低值变为零，而振幅信息（相差大小）得到保存。
    
5. **结果输出与图形显示** 将每个波周期的振幅打印在终端，同时把原始信号和扣除基线后的信号画出来，并在图中用灰色虚线标出波谷位置（作为各周期的边界），便于直观比较。
    

## 二、各个步骤与参数详细说明

### 1. 数据读取（函数 `load_data`）

- **原理**： 程序逐行读取文件内容，对于每一行：
    
    - 使用 `line.split()` 分割出各个子项；
        
    - 尝试将第一列转换为浮点数，若无法转换（代表当前行可能仅为说明文字），则自动跳过；
        
    - 如果行内至少有 4 个数据，则认为这行数据有效，取前 4 个数字保存（其中第一列作为 x，第二列为 y1，第四列为 y2）。
        
- **作用**： 保证文件中混入的文字说明不会干扰数据处理，只保留纯数值数据。
    

### 2. 信号平滑（在 `segment_by_valleys` 内部使用 Savitzky–Golay 滤波器）

- **参数：**
    
    - `SMOOTHING_WINDOW`
        
        - **作用**：决定 Savitzky–Golay 滤波器的窗口长度（采样点数），必须为奇数。
            
        - **意义**：较大的窗口能更有效地滤除噪声，但会使得局部细节模糊；较小的窗口则保留更多细节但可能受到噪声影响。
            
    - `POLYORDER`
        
        - **作用**：滤波器中拟合多项式的阶数。
            
        - **意义**：阶数越高拟合能力越强，但也容易过拟合噪声，通常选择较低阶（例如 3）。
            
- **原理**： 用滤波器重建一个平滑的信号 ysmoothy_{\text{smooth}}，这样可以让后续的局部极值（波谷）检测更稳定。
    

### 3. 波谷检测与分段（函数 `segment_by_valleys`）

- **原理**：
    
    - 对平滑后的信号 ysmoothy_{\text{smooth}} 取反，即构造 −ysmooth-y_{\text{smooth}}。 这样原来的局部最小值变成了局部最大值。
        
    - 使用 `find_peaks` 检测 −ysmooth-y_{\text{smooth}} 中的峰值，即找到原信号中的波谷。
        
    - 为防止由于噪声引起的“假波谷”，我们设置了两个参数：
        
        - **VALLEY_PROMINENCE**
            
            - **作用**：要求波谷必须具有一定“显著性”（即比周围上升至少达到一定差值），从而过滤掉宽度或深度不足、可能只是噪声造成的局部最小值。
                
            - **意义**：如果设置得过小，可能会检测到太多噪声；设置得过大则可能漏掉一些真实的波谷。
                
        - **VALLEY_DISTANCE**
            
            - **作用**：设定相邻两个波谷之间最少应有多少个采样点，防止检测到过于接近的多个波谷。
                
            - **意义**：有助于控制检测出的波谷数量，使得每个波段的分界更合理。若数据采样率较高或波周期较宽，可适当调大此参数。
                
    - 如果最终没有检测到任何波谷，则将整个信号作为1个周期。
        
- **分段输出**： 每个周期的索引存于一个字典中，包括对应的 x 和 y 子数组。这样后续就能在每一个“完整波周期”内进行单独处理。
    

### 4. 基线扣除与振幅计算（函数 `correct_segment_by_valley`）

- **原理**： 对于一个完整波周期（分段）：
    
    - 将该波段内的最小值作为“基线”，认为理论上该区域应该为0。 （这种方法简单直接，适用于如果真实基线偏移较小且噪声不大的情况下。如果需要更鲁棒的估计，可采用低百分位数的中位数作为基线。）
        
    - 扣除基线后，信号变为 ycorr=yseg−min⁡(yseg)y_{\text{corr}} = y_{\text{seg}} - \min(y_{\text{seg}})。
        
    - 振幅（波的变化量）定义为该波段的最大值与基线的差，即
        

amplitude=max⁡(yseg)−min⁡(yseg)\text{amplitude} = \max(y_{\text{seg}}) - \min(y_{\text{seg}})

- **作用**： 这样处理后，每个波的低点被归零，振幅（差值）自然保留，便于后续分析各个波的“变化量”。
    

### 5. 整体基线处理（函数 `baseline_correction_by_valleys`）

- **原理**：
    
    - 首先调用 `segment_by_valleys` 将整个信号根据检测到的波谷分段。
        
    - 对每个分段调用 `correct_segment_by_valley`，分别扣除该段的基线并计算振幅。
        
    - 将分段处理后的数据还原回一个与原信号长度一致的数组（各段数据分别修改后合并）。
        
- **作用**： 最终得到一个完全扣除了局部基线的信号，同时得到每个波的基线值和对应的振幅变化量，便于分析和比较。
    

### 6. 文件筛选与批量处理（函数 `get_valid_files` 与 `main`）

- **原理**：
    
    - 使用 `os.listdir` 遍历指定文件夹，对每个文件进行扩展名判断，筛选出文件扩展名为 “.txt”、无后缀，或者扩展名长度（除去“.”）超过 5 个字符的文件。
        
    - 在 `main` 函数中，会弹出一个文件夹选择对话框供你选择数据文件所在文件夹，然后对文件夹内所有符合条件的文件依次调用上述数据处理流程。
        
- **作用**： 实现批量自动处理，方便对多个数据文件执行同样的基线扣除和波形分析。
    

## 三、总结

整个处理过程的核心思想是先用平滑滤波使得数据稳定，然后利用波谷检测（使用 `find_peaks` 对 ­−ysmooth-y_{smooth}）来准确分割信号为完整的周期；在每个周期内，以最低值为基线进行扣除，再由周期内最大值减去该基线得到波的振幅。各个参数（如平滑窗口大小、波谷的显著性阈值等）则是用于在噪声与真实波形之间做出平衡，确保检测到的波段既完整又不受噪声干扰。

你可以根据实际数据的采样率、噪声水平以及波形特征不断调整这些参数，以获得最佳的分段和基线扣除效果。

希望这个详细说明能够帮助你更好地理解处理过程和各个参数的作用，有助于你根据具体数据情况进一步调优算法。